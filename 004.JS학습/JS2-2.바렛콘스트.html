<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS2-2. 바(var), 렛(let), 콘스트(const)</title>
    <script>

        /*************************************************** 
            변수는 바. 렛. 콘스트

            [ var ] : 함수영역 변수

            1. 함수영역에서 사용할때만 지역변수 
            2. 함수영역 바깥에서 사용하면 전역변수
            3. 전역변수와 같은 이름의 변수를 함수내에서 
            값을 할당하면 덮어쓰기가 된다.
            4. 함수 영역에서 전역변수와 같은 이름의 변수를 
            선언하면 전역변수와 다른 지역변수로 관리된다.
            (이렇게 하면 코딩이 매우 혼란스럽..워 질수도?)
            또는 변수이름이 같은 이름이지만 지역변수로 사용할 수 있다는
            장점이 되기도한다.
            ___________________________________________

            (지역변수 : Local Variable)
            함수영역내에 선언한 변수
            - 특징 : 다른 함수나 바깥(전역)영역에서 
            지역변수를 참조할 수 없다.(사용할 수 없다는 얘기)

            (전역변수 : Global Variable)
            함수밖영역에서 선언한 변수
            - 특징 : 어떤 함수에서도 전역변수를 참조할 수 있다.
            ->>> 즉, 전역변수의 값도 변경할 수 있다.
            -> 전역변수는 공유하고자 하는 데이터를 저장할 때 사용함
            __________________________________________________

            [ let ] : 블록영역변수 (중괄호는 모두 블록임) 

            1. let으로 변수를 선언하면 전역과 지역을 별도로 
            관리하여 같은 이름의 변수도 별개의 변수로 인식함

            2. let 변수는 선언후 아래쪽에서 사용해야만 한다.
            ->>> 변수 호이스팅 금지!
            (비교: var는 위에서 호출하고 아래에서 선언가능
            -> 변수의 호이스팅) -> hoist (끌어올리다... 라는 의미)

            3. 같은 영역에서 같은이름의 변수를 중복선언 불가
            (비교 : var는 중복선언이 덮어씀 - 재선언가능)

            ______________________________________________

             ****************************************

            [ const ] : 상수(constant) -> 변하지 않는값

            1. 선언과 동시에 할당해야함!

            2. 한번 할당한 값은 변경불가!

            3. 배열과 객체, 함수를 상수로 만드는 경우가 많다!
            -> 변경불가는 각 배열형, 객체형, 함수형
            -> 변경가능은 각 배열값, 객체값, 함수전달값

            4. 기타의 특징은 let과 동일함!(블록단위변수)

        ***************************************************/

        //////////////////////////////////////////////////
        // var 테스트
        //////////////////////////////////////////////////

        // JS에서 중괄호{} 란 ? 코드를 묶어주는 영역이다.

        // 1. 함수 중괄호에서 var ////////////////////////
        function callMe(){

            // 함수내에서 변수를 선언하면 지역변수이다.
            var usa = "미국";

            console.log("3. 함수안 지역 usa :",usa);

            // 함수내에서 전역변수 korea값 변경하기
            korea = "코리아";

            console.log("4. 함수안 전역 korea:",korea); 
            
            // 함수내에서 전역uk 찍기
            console.log("5. 함수안 전역 uk:" , uk);
            // -> 아래쪽에 같은 이름의 지역 uk를 만드는 순간
            // 이 변수는 지역변수로 취급된다.
            // ->>> 전역변수uk와는 영영 이별을 하게 됨
            // 결과: undifined -> 지역uk변수가 할당전에 출력됨

            // 전역변수에 선언된 uk변수와 같은이름의 지역변수만들기
            var uk = "유케이";
            console.log("6. 함수안 지역 uk:" , uk);
            
            // 선언한적이 없는 변수를 바로 사용해보자
            rabbit = "토끼";
            console.log("7.함수안 선언없는 rabbit:",rabbit);

        }/////////// callME 함수 /////////////////////////
        /////////////////////////////////////////////////

        // 함수바깥에서 변수를 선언하면 전역변수
        var korea ="한국";
        var uk = "영국";

        console.log("1. 함수밖 전역 korea:" , korea);
        console.log("2. 함수밖 전역 uk:" , uk);
        
        //callMe 함수 호출
        callMe(); 
        
        // 함수에서 전역변수값을 변경하였음
        console.log("8. 함수밖 전역 korea:" , korea);
        
        // 지역변수를 전역에서 참조할 수 없음. 참조불가 에러가 남
        // console.log("함수밖 지역 usa :",usa);
        // 에러메시지 : Uncaught ReferenceError: usa is not defined...몇째줄 코드

        // 함수안에서 선언없이 할당한 변수 rabbit 바깥에서 찍기
        console.log("9.함수밖 선언없는 rabbit:",rabbit);
        // -> 선언없이 지역에서 할당한 변수는 전역에 등록된다.
        // 변수관리가 어려워지고 나중에 소스관리에 리스크로 작용할 수 있다.
        // 선언없이 변수를 사용하지 말자! -> w3c,JS업데이트 팀 권고사항
        ///////////////////////////////////////////////////////////
        
        // 2. if문에서 중괄호 var ////////////////////////////
        if(true){
            var who = "누구?"
            console.log("if문안 who:",who);
        }//////////////if문////////////////////
        
        console.log("if문밖 who:",who);
        // if문의 중괄호 안에서 변수를 선언하면
        // 즉 중괄호가 지역역할을 못함.


        // 2-1. if문에서 중괄호 let비교 ////////////////////////////
        if(true){
            let what = "무엇?"
            console.log("if문안 what:",what);
        }//////////////if문////////////////////
        
        // console.log("if문밖 what:",what);
        // if문 중괄호 안의 let은 지역변수이므로 
        // 바깥에서 사용할 수 없다.


        // 3. for문 중괄호 var //////////////////
        for(var i =3; i>0; i--){
            console.log("for문안 i",i);
        }/////////////for문/////////////
        
        console.log("for문밖 i",i);
        // for문의 중괄호도 지역역할을 못함

        // ->>>> 결론!
        // ->>>> var 는 오직 함수의 중괄호{  } 에서만 선언시 지역변수가 된다.


        // 3-1. for문 중괄호 let //////////////////
        for(let j =3; j>0; j--){
            console.log("for문안 j",j);
        }/////////////for문/////////////
        
        // console.log("for문밖 j",j);
        // for문의 소괄호안의 셋팅은 중괄호 안으로 들어가므로
        // let변수 선언시 for중괄호 안에 선언으로 처리된다
        // 따라서 지역변수로 처리됨.
       



        //////////////////////////////////////////////////
        // let, const 테스트 /////////////////////////
        //////////////////////////////////////////////////

        var seoul = "서울";
        var jeju = "제주";
        let toktok = "카톡";
        let sport = "축구";

        // 중괄호로 블록영역을 만들어 본다. ///////////////

        /********************************************/
        {
            // 블록내부에서 전역변수 찍기! 앞
            console.log("블록내부에서 전역변수 찍기! 앞");
            console.log("seoul : ", seoul);

            // 블록에서 변수 재선언하기
            var seoul = "강남구";
            // 하단에서 변수를 전역으로 다시 선언할당한 결과임

            // console.log("jeju : ", jeju); <-에러남
            // Uncaught ReferenceError: Cannot access 'jeju' before initialization
            // let으로 선언변수는 선언전 사용불가

            // let으로 지역변수 jeju 선언
            let jeju = "마라도";
            // 중괄호안의 let은 지역변수를 생성함

            console.log("jeju : ", jeju);

            // 전역변수 let으로 선언된 같은 이름의 변수만들기
            let toktok = "라인";
            // 중괄호 바깥의 let변수와 구분함
            // 지역변수로 사용됨

            console.log("toktok : ", toktok);

            // var로 전역변수의 let변수를 다시 선언하기
            // var sport ="배구";
            // 전역에 선언된 let과 같은 이름으로 두번 변수를 선언할 수 없도록 막아준다.
            // Uncaught SyntaxError: Identifier 'sport' has already been declared

            console.log("sport : ", sport);

            // 선언하지 않은 변수를 할당하기
            myitem = "곰인형";
            console.log("myitem : ", myitem);
            // 기본적으로 선언없이 사용한 변수는 
            // var로 전역변수 선언된다.
            // 함수안에서도 마찬가지임
            // 변수에 대한 관리가 어려워진다. 나쁜케이스


            //////////////////////////////////////


            // 블록내부에서 전역변수 찍기! 뒤
            console.log("블록내부에서 전역변수 찍기! 뒤");
            console.log("seoul : ", seoul);
            console.log("jeju : ", jeju);
            console.log("toktok : ", toktok);
            console.log("sport : ", sport);
            //////////////////////////////////////
        }

            // 블록바깥에서 전역변수 찍기!
            console.log("블록바깥에서 전역변수 찍기!");
            console.log("seoul : ", seoul);
            console.log("jeju : ", jeju);
            console.log("toktok : ", toktok);
            console.log("sport : ", sport);
            console.log("myitem : ", myitem);
            ///////////////////////////////////////////


            // 변수 호이스팅(Variable Hoisting)//////
            cat = "고양이"; // 변수할당 먼저
            console.log("cat : ", cat);
            var cat; // 변수선언 나중
            // 위에서 변수에 uk의 경우와 마찬가지임
            // 변수선언을 아래서 하는 var에서만 가능
            // 문제: 코딩순서의 혼란을 야기한다.

            // let은 변수 호이스팅을 허용하는가? ///
            let dog;
            dog ="강아지";
            console.log("dog: " , dog);
            // let dog;
            // let은 변수 호이스팅을 금지한다
            // 에러메시지: JS2-2.바렛콘스트.html:221 Uncaught ReferenceError: Cannot access 'dog' before initialization
            // -> 변수의 선언과 할당에 대한 철저한 순서를 지킬수 있음
            // -> var를 사용하지 않는 중요한 이유중 하나이다.

            var cat = "먼치킨";
            // var는 재선언 가능
            // let dog ="시바견";
            // let은 재선언 불가 -> let을 쓰는 이유중 하나.
            
            ///////////// 상수 테스트 ///////////////
            // const fish;
            // fish = "고등어";    <- 이거안됨 같이설정해야함

            const fish ="고등어";
            console.log("fish:",fish);
            // 원칙1 : 상수는 선언과 함께 동시에 할당해야함

            // fish = "참치";  <- 이것도 안됨
            // 에러메시지 :
            // Uncaught TypeError: Assignment to constant variable.
            // 원칙2 : 상수는 재할당 불가능

            // 상수는 배열, 객체, 함수를 할당하여 많이 사용함

            //////////////////////////////////////////////////////
            //////    const의 활용 : 배열, 객체, 함수 //
            /////////////////////////////////////////////////

            // [ 1. 배열 ] ///
            const arr =["상추","고기","마늘"];
            console.log("배열 arr값 :", arr);

            // 재할당 불가능. 시도시 에러
            // arr = "닭고기";

            // 배열값추가
            arr.push("닭고기");
            console.log("배열 arr 닭고기추가값:", arr);

            // 배열값은 변경가능 그러나 새로운 데이터할당은 불가능

            // [ 2. 객체 ] ///
            const obj = {name : "김수현"};
            console.log("객체 obj 값: ", obj);
            
            // 역시나 재할당불가
            // obj = 100;

            // 객체에 속성추가하기 ////
            // 추가방법 : Object객체의 속성정의 메서드 사용
            // -> Object.defineProperty(객체명,속성명,{value:속성명})
            Object.defineProperty(obj,"weight",{value : "74kg"});
            console.log("객체 obj 추가한값:" , obj);

            // [ 3. 함수 ] ///
            const fn = function(txt){
                console.log("나야나",txt);
            };/////fn함수///////

            // 함수호출
            fn("ㅎㅇ");
            
            // 그밖에 배열, 객체, 함수 외에 요소를 담을경우에도 
            // 많이 사용된다.

            // 사용 이유는? 실수로 재할당될 위험에서 지키기위함.
            // 또는 보안상의 이유로 많이 사용됨 










        /********************************************/

    </script>
</head>
<body>
    
</body>
</html>